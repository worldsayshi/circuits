<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Circuits</title>
  <style>
    @import url(./style.css);

    .node {
      stroke: #fff;
      stroke-width: 1.5px;
    }

    .link {
      fill: none;
      stroke: #000;
      stroke-width: 4px;
      opacity: 0.4;
      marker-end: url(#end-arrow);
    }
  </style>
</head>

<body>
  <h1>Circuits</h1>
  <div>
    <button onclick="toggleGuides()">toggle guides</button>
  </div>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="http://marvl.infotech.monash.edu/webcola/cola.js"></script>
  <script>
    var width = 960,
      height = 900;

    var groups;
    let showGuides = false;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var d3cola = cola.d3adaptor(d3)
      .avoidOverlaps(true)
      .size([width, height]);

    var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

    d3.json("graphdata/circuit.json", function(error, graph) {
      var nodeRadius = 30;

      graph.nodes.forEach(function(v) {
        v.height = v.width = 2 * nodeRadius;
      });

      d3cola
        .nodes(graph.nodes)
        .links(graph.links)
        .groups(graph.groups)
        // .flowLayout("y", -30)
        .symmetricDiffLinkLengths(40)
        .start(10, 20, 20);

      // define arrow markers for graph links
      // svg.append('svg:defs').append('svg:marker')
      //   .attr('id', 'end-arrow')
      //   .attr('viewBox', '0 -5 10 10')
      //   .attr('refX', 6)
      //   .attr('markerWidth', 15)
      //   .attr('markerHeight', 15)
      //   .attr('orient', 'auto')
      //   .append('svg:path')
      //   .attr('d', 'M0,-5L10,0L0,5')
      //   .attr('fill', '#000');

      if (showGuides) {
        renderGroups();
      }

      var path = svg.selectAll(".link")
        .data(graph.links)
        .enter().append('svg:path')
        .attr('class', 'link');

      var node = svg.selectAll(".node")
        .data(graph.nodes)
        .enter().append("g")
        .call(d3cola.drag);

      node
        .filter(function (d) { return d.type === 'Var';})
        .append('circle')
        .attr("class", "node")
        .attr("r", nodeRadius)
        .style("fill", function(d) {
          return color(d.group);
        });

      // Append images
      var images = node.append("svg:image")
        .attr("xlink:href",  function(d) { return d.img;})
        .attr("x", function(d) { return -nodeRadius;})
        .attr("y", function(d) { return -nodeRadius;})
        .attr("height", 2*nodeRadius)
        .attr("width", 2*nodeRadius);

      node.append("title")
        .text(function(d) {
          return d.name;
        });

      function tick() {
        path.each(function(d) {
          if (isIE()) this.parentNode.insertBefore(this, this);
        });
        // draw directed edges with proper padding from node centers
        path.attr('d', function(d) {
          let varNode = d.source.type === 'Var' ? d.source : d.target;
          let varGroup = varNode.parent;
          let groupCenterX = (varGroup.bounds.X - varGroup.bounds.x) / 2 + varGroup.bounds.x;
          let groupCenterY = (varGroup.bounds.Y - varGroup.bounds.y) / 2 + varGroup.bounds.y;

          // console.log(varGroup);
          let deltaX = d.target.x - d.source.x,
            deltaY = d.target.y - d.source.y,
            dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
            normX = deltaX / dist,
            normY = deltaY / dist,
            sourcePadding = 0; // nodeRadius,
          targetPadding = 0; //nodeRadius + 2,
          sourceX = d.source.x + (sourcePadding * normX),
            sourceY = d.source.y + (sourcePadding * normY),
            targetX = d.target.x - (targetPadding * normX),
            targetY = d.target.y - (targetPadding * normY);
          return 'M' + sourceX + ',' + sourceY + 'S' + groupCenterX + ',' + groupCenterY + ' ' + targetX + ',' + targetY;
        });

        node
          .attr('transform', function (d) {return 'translate(' + d.x + ','+ d.y +')';})

        // .attr("cx", function(d) {
        //     return d.x;
        //   })
        //   .attr("cy", function(d) {
        //     return d.y;
        //   });

        if (showGuides) {
          group.attr("x", function(d) {
              return d.bounds.x;
            })
            .attr("y", function(d) {
              return d.bounds.y;
            })
            .attr("width", function(d) {
              return d.bounds.width();
            })
            .attr("height", function(d) {
              return d.bounds.height();
            });
        }
      }

      d3cola.on("tick", tick);

      window.toggleGuides = function() {
        showGuides = !showGuides;
        if (showGuides) {
          renderGroups();
        } else {
          removeGroups();
        }
        tick();
      }

      function renderGroups() {
        // console.log('renderGroups');
        group = svg.selectAll(".group")
          .data(graph.groups)
          .enter().insert("rect", ".link")
          .attr("rx", 8).attr("ry", 8)
          .attr("class", "group")
          .style("fill", function(d, i) {
            return color(i);
          })
          .call(d3cola.drag);
      }

      function removeGroups() {
        svg.selectAll(".group").remove();
      }
    });

    function isIE() {
      return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') && (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null)));
    }
  </script>

</body>

</html>
